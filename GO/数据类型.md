# 数据类型

## 方法集 method sets
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). Further rules apply to structs containing embedded fields, as described in the section on struct types. Any other type has an empty method set. In a method set, each method must have a unique non-blank method name.

The method set of a type determines the interfaces that the type implements and the methods that can be called using a receiver of that type.

## 布尔类型 bool
表示预声明的 true 或 false 代表的布尔值的集

## 数值类型 numeric
数值类型表示整数值和浮点数值的集
```
uint8       所有无符号 8位整数集（0 到 255）
uint16      所有无符号16位整数集（0 到 65535）
uint32      所有无符号32位整数集（0 到 4294967295）
uint64      所有无符号64位整数集（0 到 18446744073709551615）

int8        所有带符号 8位整数集（-128 到 127）
int16       所有带符号16位整数集（-32768 到 32767）
int32       所有带符号32位整数集（-2147483648 到 2147483647）
int64       所有带符号64位整数集（-9223372036854775808 到 9223372036854775807）

float32     所有IEEE-754 32位浮点数集
float64     所有IEEE-754 64位浮点数集

complex64   所有带float32实部和虚部的复数集
complex128  所有带float64实部和虚部的复数集

byte        uint8的别名
rune        int32的别名
```

大小取决于具体实现的预声明数值类型
```
uint     32或64位
int      大小与uint相同
uintptr  大到足以存储指针值无解释位的无符号整数
```
为避免可移植性问题，除 byte 为 uint8 的别名以及 rune 为 int32 的别名外，所有数值类型都是不同的。 当不同的数值类型混合在一个表达式或赋值操作中时，必须进行类型转换。 例如，int32 与 int 是不同的类型， 尽管它们在特定架构上可能有相同的大小。

## 字符串类型 string
字符串类型表示字符串值的集  
字符串是由单个字节连接起来的  
字符串的字节使用 UTF-8 编码标识 Unicode 文本

## 数组类型 array
一个数组（Array）就是一个可以容纳若干类型相同的元素的容器。这个容器的大小（即数组的长度）是固定的，且是体现在数组的类型字面量之中的

```
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
```

## 切片类型 slice
切片（Slice）与数组一样，也是可以容纳若干类型相同的元素的容器。与数组不同的是，无法通过切片类型来确定其值的长度。每个切片值都会将数组作为其底层数据结构。我们也把这样的数组称为切片的底层数组。

切片是数组连续段的引用及包含此数组的元素的编号序列。 切片类型表示元素类型为数组的所有切片的集。未初始化切片的值为 nil。

```
make([]T, length, capacity)

make([]int, 50, 100)
new([100]int)[0:50]
```

## 结构类型 struct
结构是已命名的元素序列，被称为字段，其中每一个元素都有一个名字和类型。 字段名可显示地指定（标识符列表）或隐式地指定（匿名字段）。 在结构中，非空白字段名必须是唯一的。

Go语言的结构体类型（Struct）比函数类型更加灵活。它可以封装属性和操作。前者即是结构体类型中的字段，而后者则是结构体类型所拥有的方法。

```
// An empty struct.
struct {}

// A struct with 6 fields.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4
struct {
	T1        // field name is T1
	*T2       // field name is T2
	P.T3      // field name is T3
	*P.T4     // field name is T4
	x, y int  // field names are x and y
}
```
```
struct {
	T     // conflicts with embedded field *T and *P.T
	*T    // conflicts with embedded field T and *P.T
	*P.T  // conflicts with embedded field T and *T
}
struct {
	x, y float64 ""  // an empty tag string is like an absent tag
	name string  "any string is permitted as a tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// A struct corresponding to a TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers;
// they follow the convention outlined by the reflect package.
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
```

## 指针类型 pointer
指针类型表示一个所有给定类型变量的指针的集，称为指针的 基础类型。 未初始化的指针的值为 nil。

指针操作涉及到两个操作符——&和*。这两个操作符均有多个用途。但是当它们作为地址操作符出现时，前者的作用是取址，而后者的作用是取值。更通俗地讲，当地址操作符&被应用到一个值上时会取出指向该值的指针值，而当地址操作符*被应用到一个指针值上时会取出该指针指向的那个值。它们可以被视为相反的操作。

```
*Point
*[4]int
```

## 函数类型 function
函数类型表示所有带相同形参和返回类型的集。未初始化的函数类型变量的的值为 nil。

我们可以把函数作为值来传递和使用。函数代表着这样一个过程：它接受若干输入（参数），并经过一些步骤（语句）的执行之后再返回输出（结果）。特别的是，Go语言中的函数可以返回多个结果。

在形参或结果的列表中，其名称（标识符列表）必须都存在或都不存在。 若存在，则每个名称代表一个指定类型的项（形参或结果），所有在签名中的非 空白名称必须是唯一的。 若不存在，则每个类型代表一个此类型的项。若恰好有一个未命名的值，它可能写作一个不加括号的类型， 除此之外，形参和结果的列表总是在括号中。

函数签名中的最后一个形参可能有一个带 ... 前缀的类型。 带这样形参的函数被称为 变参函数 它可接受零个或多个实参的函数。

```
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
```

## 接口类型 interface
接口类型指定一个称为 接口 的 方法集。 接口类型变量可存储任何带方法集类型的值，该方法集为此接口的超集。 这种类型表示 实现此接口。未初始化的接口类型变量的值为 nil。

对于所有的方法集，在一个接口类型中，每个方法必须有唯一的名字。

```
// A simple File interface
interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
```

## 映射类型 map
映射是一个同种类型元素的无序组，该类型称为元素类型； 映射通过另一类型唯一的 键 集索引，该类型称为键类型。 未初始化的映射值为 nil。

```
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}

make(map[string]int)
make(map[string]int, 100)
```

## 通道类型 channel
通道提供一种机制使两个并发执行的函数同步执行，并通过传递具体元素类型的值来通信。 未初始化的通道值为 nil。

通道（Channel）是Go语言中一种非常独特的数据结构。它可用于在不同Goroutine之间传递类型化的数据，并且是并发安全的。

Goroutine（也称为Go协程）可以被看做是承载可被并发执行的代码块的载体。它们由Go语言的运行时系统调度，并依托操作系统线程（又称内核线程）来并发地执行其中的代码块。

```
chan T          // can be used to send and receive values of type T
chan<- float64  // can only be used to send float64s
<-chan int      // can only be used to receive ints

chan<- chan int    // same as chan<- (chan int)
chan<- <-chan int  // same as chan<- (<-chan int)
<-chan <-chan int  // same as <-chan (<-chan int)
chan (<-chan int)

make(chan int, 100)
```